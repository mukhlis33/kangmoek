<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<title>Mini Photoshop Warna Tembok</title>
<style>
  body { margin:0; font-family:sans-serif; display:flex; flex-direction:column; height:100vh; }
  #toolbar { display:flex; gap:10px; padding:5px; background:#eee; flex-wrap:wrap; }
  #toolbar > * { display:flex; align-items:center; gap:5px; }
  #navbar { display:flex; gap:10px; padding:5px; flex-wrap:wrap; background:#ddd; }
  #container { flex:1; position:relative; overflow:hidden; }
  canvas { display:block; background:#fff; margin:auto; touch-action: none; }
</style>
</head>
<body>

<div id="toolbar">
  Tool:
  <button onclick="setTool('click')">Klik</button>
  <button onclick="setTool('brush')">Usap</button>
  <button onclick="setTool('erase')">Erase</button>
  <button onclick="setTool('pan')">Geser</button>
  Brush Size: <input type="range" id="brushSize" min="5" max="100" value="20">
  Brush Alpha: <input type="range" id="brushAlpha" min="0" max="1" step="0.05" value="0.4">
  Brush Shape:
  <select id="brushShape">
    <option value="circle">Bulat</option>
    <option value="ellipse">Lonjong</option>
  </select>
  Upload Gambar: <input type="file" id="upload" accept="image/*">
</div>

<div id="navbar">
  <!-- Warna zona akan muncul di sini -->
  <button onclick="addColor()">Tambah Warna</button>
</div>

<div id="container">
  <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let img = new Image();
let imgData;
let zones = [];
let colors = [{name:"Warna 1", value:"#ff0000"},{name:"Warna 2", value:"#00ff00"}];
let activeColorId = 0;
let tool = 'click';
let brushSize = 20;
let brushAlpha = 0.4;
let brushShape = 'circle';
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let startPan = {x:0,y:0};

// Responsive canvas
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight - document.getElementById('navbar').offsetHeight;
  redraw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Toolbar
document.getElementById('brushSize').addEventListener('input',(e)=>brushSize=parseInt(e.target.value));
document.getElementById('brushAlpha').addEventListener('input',(e)=>brushAlpha=parseFloat(e.target.value));
document.getElementById('brushShape').addEventListener('change',(e)=>brushShape=e.target.value);

function setTool(t){ tool = t; }

// Upload gambar
document.getElementById('upload').addEventListener('change', (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    img = new Image();
    img.onload = function(){
      offsetX=0; offsetY=0; scale=1;
      redraw();
    }
    img.src = evt.target.result;
  }
  reader.readAsDataURL(file);
});

// Navbar warna
const navbar = document.getElementById('navbar');
function renderNavbar(){
  navbar.innerHTML = '';
  colors.forEach((c,i)=>{
    const box = document.createElement('div');
    box.style.display='flex'; box.style.alignItems='center'; box.style.gap='5px';
    box.innerHTML = `<input type="radio" name="activeColor" ${i===activeColorId?'checked':''} onclick="activeColorId=${i}">
      <input type="color" value="${c.value}" onchange="colors[${i}].value=this.value; redrawZones();">
      <input type="text" value="${c.name}" onchange="colors[${i}].name=this.value;">
      ${c.name}`;
    navbar.appendChild(box);
  });
  const addBtn = document.createElement('button'); addBtn.textContent='Tambah Warna'; addBtn.onclick=addColor;
  navbar.appendChild(addBtn);
}
function addColor(){ colors.push({name:"Warna Baru",value:"#0000ff"}); renderNavbar(); }
renderNavbar();

// Coordinate transform
function toCanvasCoords(x,y){
  return {x:(x-offsetX)/scale, y:(y-offsetY)/scale};
}

// Draw
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(img.src){
    ctx.save();
    ctx.translate(offsetX,offsetY);
    ctx.scale(scale,scale);
    ctx.drawImage(img,0,0);
    ctx.restore();
  }
  redrawZones();
}

// Zones
function redrawZones(){
  if(!img.src) return;
  ctx.save();
  ctx.translate(offsetX,offsetY);
  ctx.scale(scale,scale);
  zones.forEach(z=>{
    ctx.globalAlpha = brushAlpha;
    ctx.fillStyle = colors[z.colorId].value;
    z.pixels.forEach(p=>{
      if(brushShape==='circle'){
        ctx.beginPath();
        ctx.arc(p.x,p.y,1,0,Math.PI*2);
        ctx.fill();
      } else if(brushShape==='ellipse'){
        ctx.beginPath();
        ctx.ellipse(p.x,p.y,1,2,0,0,Math.PI*2);
        ctx.fill();
      }
    });
  });
  ctx.globalAlpha =1;
  ctx.restore();
}

// Flood fill semi-smart
function floodFill(x,y,colorId){
  const tolerance = 50;
  const imgDataRaw = ctx.getImageData(0,0,img.width,img.height);
  const data = imgDataRaw.data;
  const idxStart = (Math.floor(y)*img.width+Math.floor(x))*4;
  const targetColor=[data[idxStart],data[idxStart+1],data[idxStart+2]];

  function colorDistance(a,b){ return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2); }

  let stack=[[Math.floor(x),Math.floor(y)]];
  let pixels=[];
  let visited = new Set();

  while(stack.length>0){
    const [cx,cy] = stack.pop();
    if(cx<0||cy<0||cx>=img.width||cy>=img.height) continue;
    const key = cx+","+cy;
    if(visited.has(key)) continue;
    visited.add(key);
    const idx = (cy*img.width+cx)*4;
    if(colorDistance([data[idx],data[idx+1],data[idx+2]], targetColor)>tolerance) continue;
    pixels.push({x:cx,y:cy});
    stack.push([cx+1,cy]); stack.push([cx-1,cy]); stack.push([cx,cy+1]); stack.push([cx,cy-1]);
  }
  if(pixels.length>0) zones.push({pixels,colorId});
  redraw();
}

// Brush add / erase
let drawing=false;
canvas.addEventListener('pointerdown', (e)=>{
  const {x,y}=toCanvasCoords(e.clientX,e.clientY);
  if(tool==='click'){ floodFill(x,y,activeColorId); }
  else if(tool==='brush' || tool==='erase'){ drawing=true; drawPoint(x,y); }
  else if(tool==='pan'){ isPanning=true; startPan={x:e.clientX-offsetX,y:e.clientY-offsetY}; }
});
canvas.addEventListener('pointermove', (e)=>{
  const {x,y}=toCanvasCoords(e.clientX,e.clientY);
  if(drawing && (tool==='brush' || tool==='erase')) drawPoint(x,y);
  else if(isPanning && tool==='pan'){ offsetX=e.clientX-startPan.x; offsetY=e.clientY-startPan.y; redraw(); }
});
canvas.addEventListener('pointerup', ()=>{ drawing=false; isPanning=false; });

function drawPoint(x,y){
  const px = Math.floor(x); const py=Math.floor(y);
  const colorId = (tool==='erase') ? null : activeColorId;
  let r = brushSize;
  let points=[];
  for(let dx=-r;dx<=r;dx++){
    for(let dy=-r;dy<=r;dy++){
      let dist=(brushShape==='circle')? Math.sqrt(dx*dx+dy*dy): Math.sqrt(dx*dx+2*dy*dy);
      if(dist<=r){
        if(px+dx<0||px+dx>=img.width||py+dy<0||py+dy>=img.height) continue;
        points.push({x:px+dx,y:py+dy});
      }
    }
  }
  if(tool==='erase'){
    zones.forEach(z=>{
      z.pixels = z.pixels.filter(p=> !points.some(pp=>pp.x===p.x && pp.y===p.y));
    });
  } else {
    zones.push({pixels:points,colorId});
  }
  redraw();
}

// Zoom
canvas.addEventListener('wheel', (e)=>{
  if(e.ctrlKey){
    e.preventDefault();
    let scaleFactor = e.deltaY<0 ? 1.1 : 0.9;
    scale *= scaleFactor;
    if(scale>5) scale=5; if(scale<0.1) scale=0.1;
    redraw();
  }
}, {passive:false});

// Touch zoom
let lastDist=0;
canvas.addEventListener('touchmove', (e)=>{
  if(e.touches.length===2){
    e.preventDefault();